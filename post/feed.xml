<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on xdzhcs</title>
    <link>/post/</link>
    <description>Recent content in Posts on xdzhcs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 30 Oct 2016 17:13:10 +0800</lastBuildDate>
    <atom:link href="/post/feed/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>实现可放缩移动的ImageView</title>
      <link>/post/diy-zoom-imageview/</link>
      <pubDate>Sun, 30 Oct 2016 17:13:10 +0800</pubDate>
      
      <guid>/post/diy-zoom-imageview/</guid>
      <description>

&lt;h2 id=&#34;可放缩可移动的imageview&#34;&gt;可放缩可移动的ImageView&lt;/h2&gt;

&lt;p&gt;主要参考了&lt;br /&gt;
&lt;a href=&#34;http://blog.csdn.net/lmj623565791/article/details/39474553&#34;&gt;http://blog.csdn.net/lmj623565791/article/details/39474553&lt;/a&gt;
&lt;a href=&#34;http://blog.csdn.net/lmj623565791/article/details/39480503&#34;&gt;http://blog.csdn.net/lmj623565791/article/details/39480503&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package xyz.xdzhcs.zoomanddrafting;

import android.content.Context;
import android.graphics.Matrix;
import android.graphics.RectF;
import android.graphics.drawable.Drawable;
import android.support.v4.widget.DrawerLayout;
import android.util.AttributeSet;
import android.util.Log;
import android.view.GestureDetector;
import android.view.MotionEvent;
import android.view.ScaleGestureDetector;
import android.view.ViewTreeObserver;
import android.widget.ImageView;

public class ZoomImageView extends ImageView implements ScaleGestureDetector.OnScaleGestureListener
    ,ViewTreeObserver.OnGlobalLayoutListener
{
    //边缘不能触发触摸事件的距离，避免与其他布局（比如drawer_layout）的冲突
    private static final int edge=20;
    //最大放大倍数
    private  static final float SCALE_MAX=4.0f;
    //中间放大倍数
    private static final float SCALE_MID=1.5f;
    //初始化时的缩放比例，如果图片宽或者高大于屏幕，此值将小于1.0
    private float initScale=1.0f;
    //用于存放矩阵的9个值
    private  float[] matrixValues=new float[9];
    //缩放手势检测
    private ScaleGestureDetector scaleGestureDetector;
    //手势检测，只用来检测双击
    private GestureDetector gestureDetector;
    //变换矩阵
    private Matrix matrix=new Matrix();
    //首次加载标志
    private boolean isFirst=true;
    //是否正在放缩图片
    private boolean isScaling=false;
    //上次触摸事件发生时的触摸点数目
    private int lastPointerCount=0;
    //上次的x,y坐标
    private float lastX=0.0f;
    private float lastY=0.0f;

    public ZoomImageView(Context context) {
        //super(context);
        this(context,null);
    }


    public ZoomImageView(Context context, AttributeSet attrs) {
        super(context, attrs);
        super.setScaleType(ScaleType.MATRIX);
        scaleGestureDetector = new ScaleGestureDetector(context,this);//this参  数是监听器
        gestureDetector=new GestureDetector(new GestureDetector.SimpleOnGestureListener(){
            @Override
            public boolean onDoubleTap(MotionEvent e) {
                //return super.onDoubleTap(e);
                Log.i(&amp;quot;info&amp;quot;,&amp;quot;onDoubleTap&amp;quot;);
                float curScale=getScale();
                if(curScale&amp;gt;=SCALE_MAX){
                    //当前已经是最大的放大倍数了，双击后要缩小到初始化的大小
                    ZoomImageView.this.postDelayed(new AutoScaleRunnable(initScale,getWidth()/2,getHeight()/2),16);
                }else if(curScale&amp;gt;=SCALE_MID){
                    //当前是中等放大倍数，双击后腰变到最大
                    ZoomImageView.this.postDelayed(new AutoScaleRunnable(SCALE_MAX,getWidth()/2,getHeight()/2),16);
                }else {
                    //当前是初始化的放大倍数，双击后去到中等大小
                    ZoomImageView.this.postDelayed(new AutoScaleRunnable(SCALE_MID,getWidth()/2,getHeight()/2),16);
                }
                isScaling=true;
                //new Thread(new AutoScaleThread()).start();
                return true;
            }
        });

    }

    /**
     * 获取当前缩放系数
     * @return
     */
    public float getScale(){
        matrix.getValues(matrixValues);
        return matrixValues[Matrix.MSCALE_X];
    }

    @Override
    public boolean onScale(ScaleGestureDetector scaleGestureDetector) {
        if(isScaling)return true;
        float curScale = getScale(); //当前矩阵的缩放系数
        float toScale = scaleGestureDetector.getScaleFactor();//想要进行的放缩系数

        if(getDrawable()==null)
            return true;

        //缩放范围控制
        if((curScale&amp;lt;SCALE_MAX&amp;amp;&amp;amp;toScale&amp;gt;1.0f)
                ||(curScale&amp;gt;initScale&amp;amp;&amp;amp;toScale&amp;lt;1.0f)){
            //最小值
            if(toScale*curScale&amp;lt;initScale){
                toScale=initScale/curScale;
            }
            //最大
            if(toScale*curScale&amp;gt;SCALE_MAX){
                toScale=SCALE_MAX/curScale;
            }
            //设置
            matrix.postScale(toScale,toScale,getWidth()/2,getHeight()/2);
            setImageMatrix(matrix);
        }

        return true;
    }

    @Override
    public boolean onScaleBegin(ScaleGestureDetector scaleGestureDetector) {
        return true;
    }

    @Override
    public void onScaleEnd(ScaleGestureDetector scaleGestureDetector) {

    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if(event.getX()&amp;lt;edge||event.getY()&amp;lt;edge
                ||event.getX()&amp;gt;getWidth()-edge||event.getY()&amp;gt;getHeight()-edge){
            return false;
        }
        if(isScaling)return true;
        if(gestureDetector.onTouchEvent(event)){
            return true;
        }

        scaleGestureDetector.onTouchEvent(event);


        if(getDrawable()==null){
            return true;
        }

        float x=0;
        float y=0;
        int pointerCount=event.getPointerCount();
        for(int i=0;i&amp;lt;pointerCount;i++){
            x+=event.getX(i);
            y+=event.getY(i);
        }
        x = x / pointerCount;
        y = y / pointerCount;
        //触摸点数目发生变化时，重置lastY,lastY，此次不滑动
        if(pointerCount!=lastPointerCount){
            lastX=x;
            lastY=y;
            lastPointerCount=pointerCount;
            return true;
        }
        Log.i(&amp;quot;info&amp;quot;,&amp;quot;x:&amp;quot;+x+&amp;quot;y:&amp;quot;+y);
        switch (event.getAction()){
            case MotionEvent.ACTION_MOVE:
                RectF rect=getMatrixRectF();
                float dx=x-lastX;
                float dy=y-lastY;
                matrix.postTranslate(dx,dy);
                checkPosition();
                setImageMatrix(matrix);
                Log.i(&amp;quot;info&amp;quot;,&amp;quot;dx:&amp;quot;+dx+&amp;quot;dy:&amp;quot;+dy);
                break;
            default:
                break;
        }
        lastX=x;
        lastY=y;
        return true;
    }

    @Override
    public void onGlobalLayout() {
        //以下代码的作用是指定初始放缩参数，即默认的放缩大小
        if(isFirst){
            Drawable d=getDrawable();
            if(d==null){
                return;
            }

            int picHeight=d.getIntrinsicHeight(); //图片内容高度
            int picWidth=d.getIntrinsicWidth(); //图片内容宽度
            int viewHeight=getHeight(); //View组件高度
            int viewWidth=getWidth();   //View组件宽度
            float scale=1.0f;
            //如果图片内容的高大于屏幕的高，则缩放到屏幕的高
            if(picHeight&amp;gt;viewHeight&amp;amp;&amp;amp;picWidth&amp;lt;=viewWidth){
                scale=viewHeight*1.0f/picHeight;
            }
            //如果图片内容的宽大于屏幕的高，则缩放到屏幕的高
            if(picWidth&amp;gt;viewWidth&amp;amp;&amp;amp;picHeight&amp;lt;=viewHeight){
                scale=viewWidth*1.0f/picWidth;
            }
            //如果图片内容的宽和高都大于屏幕的宽和高，取宽和高最小的缩放指数
            if(picHeight&amp;gt;viewHeight&amp;amp;&amp;amp;picWidth&amp;gt;viewWidth){
                scale=Math.min(viewHeight*1.0f/picHeight,viewWidth*1.0f/picWidth);
            }
            initScale=scale;//初始放缩参数
            Log.i(&amp;quot;info&amp;quot;,&amp;quot;initScale:&amp;quot;+initScale);
            //matrix.postScale(initScale,initScale);

            //把图片移动到view中心

            matrix.postTranslate((viewWidth-picWidth)/2,(viewHeight-picHeight)/2);

            RectF rect=getMatrixRectF();
            matrix.setScale(initScale,initScale);
            checkPosition();
            setImageMatrix(matrix);
            isFirst=false;
        }
    }

    @Override
    protected void onAttachedToWindow() {
        super.onAttachedToWindow();
        getViewTreeObserver().addOnGlobalLayoutListener(this);
    }

    @Override
    protected void onDetachedFromWindow() {
        super.onDetachedFromWindow();
        getViewTreeObserver().removeGlobalOnLayoutListener(this);
    }

    /**
     * 在滑动滑动的时候，对图片显示范围进行控制
     */
    private void checkPosition(){

        RectF rect=getMatrixRectF();
        float dx=0;
        float dy=0;

        int viewHeight=getHeight(); //View组件高度
        int viewWidth=getWidth();   //View组件宽度

        //如果图片高大于View的高，不能出现白边
        if(rect.height()&amp;gt;viewHeight){
            if(rect.top&amp;gt;0){
                dy=-rect.top;
            }
            if(rect.bottom&amp;lt;viewHeight){
                dy=viewHeight-rect.bottom;
            }
        }
        //如果图片宽大于View的宽，不能出现白边
        if(rect.width()&amp;gt;viewWidth){
            if(rect.left&amp;gt;0){
                dx=-rect.left;
            }
            if(rect.right&amp;lt;viewWidth){
                dx=viewWidth-rect.right;
            }
        }
        //如果宽小于view的宽，居中
        if(rect.width()&amp;lt;=viewWidth){
            dx=viewWidth*0.5f-rect.right+rect.width()*0.5f;
        }
        //如果高小于viwe的高，居中
        if(rect.height()&amp;lt;=viewHeight){
            dy=viewHeight*0.5f-rect.bottom+rect.height()*0.5f;
        }
        matrix.postTranslate(dx,dy);
    }

    /**
     * 获取图片图片内容形成的矩形
     * @return
     */
    private RectF getMatrixRectF()
    {
        Matrix matrix = this.matrix;
        RectF rect = new RectF();
        Drawable d = getDrawable();
        if (null != d)
        {
            rect.set(0, 0, d.getIntrinsicWidth(), d.getIntrinsicHeight());
            matrix.mapRect(rect);
        }
        return rect;
    }


    /**
     * 自动缩放的任务
     */
    private class AutoScaleRunnable implements Runnable
    {
        static final float BIGGER = 1.07f;
        static final float SMALLER = 0.93f;
        private float targetScale;
        private float tmpScale;
        /**
         * 缩放的中心
         */
        private float x;
        private float y;

        /**
         * 传入目标缩放值，根据目标值与当前值，判断应该放大还是缩小
         * @param targetScale
         */
        public AutoScaleRunnable(float targetScale, float x, float y)
        {
            this.targetScale = targetScale;
            this.x = x;
            this.y = y;
            if (getScale() &amp;lt; targetScale)
            {
                tmpScale = BIGGER;
            } else
            {
                tmpScale = SMALLER;
            }

        }

        @Override
        public void run()
        {
            // 进行缩放
            matrix.postScale(tmpScale, tmpScale, x, y);
            checkPosition();
            setImageMatrix(matrix);

            final float currentScale = getScale();
            // 如果值在合法范围内，继续缩放
            if (((tmpScale &amp;gt; 1f) &amp;amp;&amp;amp; (currentScale &amp;lt; targetScale))
                    || ((tmpScale &amp;lt; 1f) &amp;amp;&amp;amp; (targetScale &amp;lt; currentScale)))
            {
                ZoomImageView.this.postDelayed(this, 16);
            } else
            // 设置为目标的缩放比例
            {
                final float deltaScale = targetScale / currentScale;
                matrix.postScale(deltaScale, deltaScale, x, y);
                checkPosition();
                setImageMatrix(matrix);
                isScaling = false;
            }

        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>activity与service的通信</title>
      <link>/post/communication-between-activity-and-service/</link>
      <pubDate>Sun, 23 Oct 2016 11:50:52 +0800</pubDate>
      
      <guid>/post/communication-between-activity-and-service/</guid>
      <description>

&lt;p&gt;Activity和Service之间的通信主要有两种形式
1. Binder作为桥梁进行通信
2. 通过广播通信&lt;/p&gt;

&lt;h3 id=&#34;通过binder通信&#34;&gt;通过Binder通信&lt;/h3&gt;

&lt;p&gt;我们知道启动一个Service可以使用startService方法或者bindService方法。
来看看bindService方法&lt;br /&gt;
&lt;code&gt;boolean bindService (Intent service, ServiceConnection conn, int flags)&lt;/code&gt;&lt;br /&gt;
第二个参数是一个ServiceConnection对象，里面有两个必须重写的方法&lt;br /&gt;
&lt;code&gt;public void onServiceDisconnected(ComponentName name)&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;public void onServiceConnected(ComponentName name, IBinder service)&lt;/code&gt;&lt;br /&gt;
在bindService绑定Service之后会自动调用onServiceConnected方法,参数里有个IBinder对象，我们只需要在Service里面定义好这个IBinder对象(在Service的onBind方法中返回)，我们在Activity中就可以通过它操作Service了。
上代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package xyz.xdzhcs.servicedemo;

import android.app.Service;
import android.content.Intent;
import android.os.Binder;
import android.os.IBinder;
import android.support.annotation.Nullable;

/**
 * Created by xdzhcs on 2016/10/23.
 */
public class DownloadService extends Service {

    private int progress=0;

    /**
     * 开始下载(更新progress)
     */
    public void startDownload(){
       new Thread(new Runnable() {
           @Override
           public void run() {
               while (progress&amp;lt;100){
                   //做了一些事情......进度更新了
                   progress++;
                   try {
                       Thread.sleep(1000);
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
               }
           }
       }).start();
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return new MyBinder();
    }
    class MyBinder extends Binder{
        public void startDownload(){
            DownloadService.this.startDownload();
        }
        public int getProgress(){
            return progress;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;package xyz.xdzhcs.servicedemo;

import android.content.ComponentName;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.IBinder;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.view.View;
import android.widget.Toast;

public class MainActivity extends AppCompatActivity {

    private DownloadService.MyBinder binder;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        //绑定Service
        Intent intent=new Intent(this,DownloadService.class);
        bindService(intent,conn,BIND_AUTO_CREATE);

        //开始下载
        findViewById(R.id.btn_start_download).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                binder.startDownload();
                Toast.makeText(MainActivity.this,&amp;quot;已经开始下载&amp;quot;,Toast.LENGTH_SHORT).show();
            }
        });

        //获取当前下载进度
        findViewById(R.id.btn_get_progress).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                int progress=binder.getProgress();
                Toast.makeText(MainActivity.this,&amp;quot;当前下载进度：&amp;quot;+progress,Toast.LENGTH_SHORT).show();
            }
        });
    }
    ServiceConnection conn=new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName componentName, IBinder iBinder) {
            binder= (DownloadService.MyBinder) iBinder;
            Toast.makeText(MainActivity.this,&amp;quot;绑定成功&amp;quot;,Toast.LENGTH_SHORT);
        }

        @Override
        public void onServiceDisconnected(ComponentName componentName) {

        }
    };
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;点击开始下载，然后每点一次获取进度就可以调用binder中的getProgress方法返回当前进度了，效果如下。&lt;br /&gt;
&lt;img src=&#34;/img/communication-between-activity-and-service/img1.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;/img/communication-between-activity-and-service/img2.png&#34; alt=&#34;&#34; /&gt;
所以到目前为止，已经实现了从Activity操纵Service了，但是这种获取进度的方法也太不优雅了吧，有没有方法可以让Service主动通知Activity下载进度呢？当然有，那就是：回调！
定义一个接口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface OnProgressListener {
    void onProgressChanged(int progress);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Service里放一个接口的实例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private OnProgressListener listener;

    public void setListener(OnProgressListener listener) {
        this.listener = listener;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Activity中实现这个接口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; binder.setListener(new OnProgressListener() {
                @Override
                public void onProgressChanged(final int progress) {
                    runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            Toast.makeText(MainActivity.this,&amp;quot;当前下载进度：&amp;quot;+progress,Toast.LENGTH_SHORT).show();
                        }
                    });

                }
            });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每次Service有更新时，就可以通过listener来告诉Activity了
&lt;code&gt;listener.onProgressChanged(progress);&lt;/code&gt;
最后所有的代码看起来是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package xyz.xdzhcs.servicedemo;

import android.app.Service;
import android.content.Intent;
import android.os.Binder;
import android.os.IBinder;
import android.support.annotation.Nullable;

/**
 * Created by xdzhcs on 2016/10/23.
 */
public class DownloadService extends Service {

    private int progress=0;
    private OnProgressListener listener;

    /**
     * 开始下载(更新progress)
     */
    public void startDownload(){
       new Thread(new Runnable() {
           @Override
           public void run() {
               while (progress&amp;lt;100){
                   //做了一些事情......进度更新了
                   progress++;
                   //通知activity更新进度
                   listener.onProgressChanged(progress);
                   try {
                       Thread.sleep(1000);
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
               }
           }
       }).start();
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return new MyBinder();
    }
    class MyBinder extends Binder{
        public void startDownload(){
            DownloadService.this.startDownload();
        }
        public int getProgress(){
            return progress;
        }
        public void setListener(OnProgressListener listener) {
            DownloadService.this.listener=listener;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;package xyz.xdzhcs.servicedemo;

import android.content.ComponentName;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.IBinder;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.view.View;
import android.widget.Toast;

public class MainActivity extends AppCompatActivity {

    private DownloadService.MyBinder binder;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        //绑定Service
        Intent intent=new Intent(this,DownloadService.class);
        bindService(intent,conn,BIND_AUTO_CREATE);

        //开始下载
        findViewById(R.id.btn_start_download).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                binder.startDownload();
                Toast.makeText(MainActivity.this,&amp;quot;已经开始下载&amp;quot;,Toast.LENGTH_SHORT).show();
            }
        });

        //获取当前下载进度
        findViewById(R.id.btn_get_progress).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                int progress=binder.getProgress();
                Toast.makeText(MainActivity.this,&amp;quot;当前下载进度：&amp;quot;+progress,Toast.LENGTH_SHORT).show();
            }
        });
    }
    ServiceConnection conn=new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName componentName, IBinder iBinder) {
            binder= (DownloadService.MyBinder) iBinder;
            Toast.makeText(MainActivity.this,&amp;quot;绑定成功&amp;quot;,Toast.LENGTH_SHORT);
            binder.setListener(new OnProgressListener() {
                @Override
                public void onProgressChanged(final int progress) {
                    runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            Toast.makeText(MainActivity.this,&amp;quot;当前下载进度：&amp;quot;+progress,Toast.LENGTH_SHORT).show();
                        }
                    });

                }
            });
        }

        @Override
        public void onServiceDisconnected(ComponentName componentName) {

        }
    };
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就能自动更新进度了。&lt;/p&gt;

&lt;h3 id=&#34;使用brocastreceiver进行通信&#34;&gt;使用BrocastReceiver进行通信&lt;/h3&gt;

&lt;p&gt;基本思路为，在Activity中注册BrocastReceiver，然后在Service中发送广播（带上progress的数值）,在Activity中接收到广播并处理,代码如下.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package xyz.xdzhcs.servicedemo;

import android.app.Service;
import android.content.Intent;
import android.os.Binder;
import android.os.IBinder;
import android.support.annotation.Nullable;

/**
 * Created by xdzhcs on 2016/10/23.
 */
public class DownloadService extends Service {

    private int progress=0;

    /**
     * 开始下载(更新progress)
     */
    public void startDownload(){
       new Thread(new Runnable() {
           @Override
           public void run() {
               while (progress&amp;lt;100){
                   //做了一些事情......进度更新了
                   progress++;
                   //发送广播
                   Intent intent = new Intent(&amp;quot;xyz.xdzhcs.servicedomo.UPDATE_PROGRESS&amp;quot;);
                   intent.putExtra(&amp;quot;progress&amp;quot;,progress);
                   sendBroadcast(intent);
                   try {
                       Thread.sleep(1000);
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
               }
           }
       }).start();
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        startDownload();
        return super.onStartCommand(intent, flags, startId);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;package xyz.xdzhcs.servicedemo;

import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.os.IBinder;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.view.View;
import android.widget.Toast;

public class MainActivity extends AppCompatActivity {

    private Intent intent;
    private ProgressReceiver receiver;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        intent = new Intent(MainActivity.this,DownloadService.class);
        receiver=new ProgressReceiver();
        //注册广播接收器
        IntentFilter filter=new IntentFilter();
        filter.addAction(&amp;quot;xyz.xdzhcs.servicedomo.UPDATE_PROGRESS&amp;quot;);
        registerReceiver(receiver,filter);
        //开始下载
        findViewById(R.id.btn_start_download).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Toast.makeText(MainActivity.this,&amp;quot;已经启动服务开始下载&amp;quot;,Toast.LENGTH_SHORT).show();
                startService(intent);
            }
        });

    }
    /**
     *  广播接收器
     */
    public class ProgressReceiver extends BroadcastReceiver{

        @Override
        public void onReceive(Context context, Intent intent) {
            int progress = intent.getIntExtra(&amp;quot;progress&amp;quot;,0);
            Toast.makeText(MainActivity.this,&amp;quot;当前进度为:&amp;quot;+progress,Toast.LENGTH_SHORT).show();
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        unregisterReceiver(receiver);
        stopService(intent);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果和前面的差不多,在Activity中调用startService启动了Service以后，Service会马上在onStartCommand方法中调用startDownload。在progress数值更新以后，service发送广播，activity接收到广播并进行处理。
这就实现了单向的从Service向Activity中发送信息了。那么如何从Activity想Service中发消息呢?这还不简单，在Service里注册广播接收器，从Activity发送广播，Service根据广播中附带的信息进行相应操作就好了。&lt;/p&gt;

&lt;h3 id=&#34;小结&#34;&gt;小结&lt;/h3&gt;

&lt;h5 id=&#34;使用binder通信&#34;&gt;使用binder通信&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Activity&amp;ndash;&amp;gt;Service 通过 Activity通过Binder调用Service&lt;/li&gt;
&lt;li&gt;Service&amp;ndash;&amp;gt;Activity 使用回调&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;使用广播通信&#34;&gt;使用广播通信&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Activity &amp;lt;&amp;ndash;&amp;gt; Service 注册广播接收器，互发广播&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 20 Valid Parentheses</title>
      <link>/post/leetcode-20-valid-parentheses/</link>
      <pubDate>Sun, 18 Sep 2016 11:00:44 +0800</pubDate>
      
      <guid>/post/leetcode-20-valid-parentheses/</guid>
      <description>

&lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/valid-parentheses/&#34;&gt;https://leetcode.com/problems/valid-parentheses/&lt;/a&gt;
&amp;gt;Given a string containing just the characters &amp;lsquo;(&amp;rsquo;, &amp;lsquo;)&amp;rsquo;, &amp;lsquo;{&amp;rsquo;, &amp;lsquo;}&amp;rsquo;, &amp;lsquo;[&amp;rsquo; and &amp;lsquo;]&amp;rsquo;, determine if the input string is valid.
The brackets must close in the correct order, &amp;ldquo;()&amp;rdquo; and &amp;ldquo;()[]{}&amp;rdquo; are all valid but &amp;ldquo;(]&amp;rdquo; and &amp;ldquo;([)]&amp;rdquo; are not.&lt;/p&gt;

&lt;h3 id=&#34;题意&#34;&gt;题意&lt;/h3&gt;

&lt;p&gt;括号匹配问题。给出一个字符串，里面只有&amp;rsquo;(&amp;lsquo;, &amp;lsquo;)&amp;rsquo;, &amp;lsquo;{&amp;rsquo;, &amp;lsquo;}&amp;rsquo;, &amp;lsquo;[&amp;lsquo;6种字符，求括号是否合法匹配。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;用栈结构。&lt;/p&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    public boolean isValid(String s) {
        Stack&amp;lt;Character&amp;gt; stack=new Stack&amp;lt;&amp;gt;();
        for(int i=0;i&amp;lt;s.length();i++){
            if(!stack.isEmpty()){
                switch ((char)stack.peek()) {
                case &#39;(&#39;:
                    if(s.charAt(i)==&#39;)&#39;)stack.pop();
                    else stack.push(s.charAt(i));
                    break;
                case &#39;[&#39;:
                    if(s.charAt(i)==&#39;]&#39;)stack.pop();
                    else stack.push(s.charAt(i));
                    break;
                case &#39;{&#39;:
                    if(s.charAt(i)==&#39;}&#39;)stack.pop();
                    else stack.push(s.charAt(i));
                    break;
                default:
                    break;
                }
            }else {
                stack.push(s.charAt(i));
            }
        }
        return stack.isEmpty();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 3 Longest Substring Without Repeating Characters</title>
      <link>/post/leetcode-3-longest-substring-without-repeating-characters/</link>
      <pubDate>Sat, 17 Sep 2016 20:53:00 +0800</pubDate>
      
      <guid>/post/leetcode-3-longest-substring-without-repeating-characters/</guid>
      <description>

&lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/longest-substring-without-repeating-characters/&#34;&gt;https://leetcode.com/problems/longest-substring-without-repeating-characters/&lt;/a&gt;
&amp;gt;Given a string, find the length of the longest substring without repeating characters.
Examples:
Given &amp;ldquo;abcabcbb&amp;rdquo;, the answer is &amp;ldquo;abc&amp;rdquo;, which the length is 3.
Given &amp;ldquo;bbbbb&amp;rdquo;, the answer is &amp;ldquo;b&amp;rdquo;, with the length of 1.
Given &amp;ldquo;pwwkew&amp;rdquo;, the answer is &amp;ldquo;wke&amp;rdquo;, with the length of 3. Note that the answer must be a substring, &amp;ldquo;pwke&amp;rdquo; is a subsequence and not a substring.&lt;/p&gt;

&lt;h3 id=&#34;题意&#34;&gt;题意&lt;/h3&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
        public int lengthOfLongestSubstring(String s) {
        boolean[] flag=new boolean[128];
        int begin=0;
        int max=0;
        for(int i=0;i&amp;lt;s.length();){
            if(flag[s.charAt(i)]==false){
                //如果字串中没有出现该字母，则标记为已出现
                flag[s.charAt(i)]=true;
                i++;
            }else {
                //如果子串种已经出现该字母，则算当前子串长度，并与最大值进行比较
                int length=i-begin;
                if(length&amp;gt;max){
                    max=length;
                }
                //begin自加，并且把对应的字符标记为没出现
                for(;;){
                    flag[s.charAt(begin)]=false;
                    if (((int)(s.charAt(begin))==(int)(s.charAt(i)))) {
                        begin++;
                        break;
                    }
                    begin++;
                    
                };
            }
        }
        int length=s.length()-begin;
        
        if(length&amp;gt;max){
            max=length;
        }
        return max;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 1 Two Sum</title>
      <link>/post/leetcode-1-two-sum/</link>
      <pubDate>Sat, 17 Sep 2016 20:52:05 +0800</pubDate>
      
      <guid>/post/leetcode-1-two-sum/</guid>
      <description>

&lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/two-sum/&#34;&gt;https://leetcode.com/problems/two-sum/&lt;/a&gt;
&amp;gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution.
Example:
Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
UPDATE (2016/2/13):
The return format had been changed to zero-based indices. Please read the above updated description carefully.&lt;/p&gt;

&lt;h3 id=&#34;题意&#34;&gt;题意&lt;/h3&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
     public int[] twoSum(int[] nums, int target) {
        for(int i=0;i&amp;lt;nums.length;i++){
            for(int j=i+1;j&amp;lt;nums.length;j++){
                if(nums[i]+nums[j]==target){
                    return new int[]{i,j};
                }
            }
        }
        return new int[]{0,0};
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 2 Add Two Numbers</title>
      <link>/post/leetcode-2-add-Two-numbers/</link>
      <pubDate>Sat, 17 Sep 2016 20:52:05 +0800</pubDate>
      
      <guid>/post/leetcode-2-add-Two-numbers/</guid>
      <description>

&lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/add-two-numbers/&#34;&gt;https://leetcode.com/problems/add-two-numbers/&lt;/a&gt;
&amp;gt;You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)
Output: 7 -&amp;gt; 0 -&amp;gt; 8&lt;/p&gt;

&lt;h3 id=&#34;题意&#34;&gt;题意&lt;/h3&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        int flag=0;
        int val=l1.val+l2.val+flag;
        ListNode l3=new ListNode(val%10);
        ListNode res=l3;
        flag=val/10;
        l1=l1.next;
        l2=l2.next;
        //ListNode next=l3.next;
        while(l1!=null&amp;amp;&amp;amp;l2!=null){
            int value=l1.val+l2.val+flag;
            //next=new ListNode(val%10);
            l3.next=new ListNode(value%10);
            flag=value/10;
            l1=l1.next;
            l2=l2.next;
            //next=next.next;
            l3=l3.next;
        }
        while(l1!=null){
            int value=l1.val+flag;
            l3.next=new ListNode(value%10);
            flag=value/10;
            l1=l1.next;
            l3=l3.next;
        }
        while(l2!=null){
            int value=l2.val+flag;
            l3.next=new ListNode(value%10);
            flag=value/10;
            l2=l2.next;
            l3=l3.next;
        }
        if(flag!=0){
            l3.next=new ListNode(flag);
        }
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 4 Median of Two Sorted Arrays</title>
      <link>/post/leetcode-4-median-of-two-sorted-arrays/</link>
      <pubDate>Sat, 17 Sep 2016 20:52:05 +0800</pubDate>
      
      <guid>/post/leetcode-4-median-of-two-sorted-arrays/</guid>
      <description>

&lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/median-of-two-sorted-arrays/&#34;&gt;https://leetcode.com/problems/median-of-two-sorted-arrays/&lt;/a&gt;
&amp;gt;There are two sorted arrays nums1 and nums2 of size m and n respectively.
Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
Example 1:
nums1 = [1, 3]
nums2 = [2]
The median is 2.0
Example 2:
nums1 = [1, 2]
nums2 = [3, 4]
The median is (2 + 3)/2 = 2.5&lt;/p&gt;

&lt;h3 id=&#34;题意&#34;&gt;题意&lt;/h3&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int num=nums1.length+nums2.length;
        int i=0,j=0,cnt=0,n1=0,n2=0;
        while(cnt&amp;lt;num/2+1&amp;amp;&amp;amp;i&amp;lt;nums1.length&amp;amp;&amp;amp;j&amp;lt;nums2.length){
            
            if(nums1[i]&amp;lt;nums2[j]){
                n1=n2;
                n2=nums1[i];
                i++;
            }else {
                n1=n2;
                n2=nums2[j];
                j++;
            }
            cnt++;
        }
        while(cnt&amp;lt;num/2+1&amp;amp;&amp;amp;i&amp;lt;nums1.length){
            
            n1=n2;
            n2=nums1[i];
            i++;
            cnt++;
        }
        while(cnt&amp;lt;num/2+1&amp;amp;&amp;amp;j&amp;lt;nums2.length){
            
            n1=n2;
            n2=nums2[j];
            j++;
            cnt++;
        }
        //System.out.println(&amp;quot;n1:&amp;quot;+n1+&amp;quot; n2:&amp;quot;+n2);
        if(num%2==0){
            //如果两个数组的总数为偶数,则中位数为第n/2和第n/2+1个数的平均数,从1开始
            return (n1+n2)/2.0;
        }else {
            //如果两个数组的总数为奇数,则中位数为第n/2+1个数,从1开始
            return n2/1.0;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 5 Longest Palindromic Substring </title>
      <link>/post/leetcode-5-longest-palindromic-substring/</link>
      <pubDate>Sat, 17 Sep 2016 20:52:05 +0800</pubDate>
      
      <guid>/post/leetcode-5-longest-palindromic-substring/</guid>
      <description>

&lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/longest-palindromic-substring/&#34;&gt;https://leetcode.com/problems/longest-palindromic-substring/&lt;/a&gt;
&amp;gt;Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.
Subscribe to see which companies asked this question&lt;/p&gt;

&lt;h3 id=&#34;题意&#34;&gt;题意&lt;/h3&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
   //最长回文字串 长度最长为N
    public String longestPalindrome(String s) {
        int max=0,cur=0,maxIndex=0;
        for(int i=0;i&amp;lt;s.length();i++){
            cur=1;
            int j=1;
            //奇数回文串
            for(j=1;i-j&amp;gt;=0&amp;amp;&amp;amp;i+j&amp;lt;s.length();j++){
                if(s.charAt(i-j)==s.charAt(i+j)){
                    cur+=2;
                }else {
                    break;
                }
            }
            if(cur&amp;gt;max){
                max=cur;
                maxIndex=i-cur/2;
                
                //System.out.println(&amp;quot;max:&amp;quot;+max+&amp;quot;,index:&amp;quot;+maxIndex+&amp;quot;,i:&amp;quot;+i+&amp;quot; &amp;quot;);
                //System.out.println(s.substring(maxIndex,max));
            }
            //偶数回文串
            cur=0;
            for(j=0;i-j&amp;gt;=0&amp;amp;&amp;amp;i+1+j&amp;lt;s.length();j++){
                if(s.charAt(i-j)==s.charAt(i+1+j)){
                    cur+=2;
                }else {
                    break;
                }
            }
            if(cur&amp;gt;max){
                max=cur;
                maxIndex=i-cur/2+1;
                
                //System.out.println(&amp;quot;max:&amp;quot;+max+&amp;quot;,index:&amp;quot;+maxIndex+&amp;quot;,i:&amp;quot;+i+&amp;quot; &amp;quot;);
                //System.out.println(s.substring(maxIndex,max));
            }
        }
        return s.substring(maxIndex, maxIndex+max);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 6 ZigZag Conversion</title>
      <link>/post/leetcode-6-zigzag-conversion/</link>
      <pubDate>Sat, 17 Sep 2016 20:52:05 +0800</pubDate>
      
      <guid>/post/leetcode-6-zigzag-conversion/</guid>
      <description>

&lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/zigzag-conversion/&#34;&gt;https://leetcode.com/problems/zigzag-conversion/&lt;/a&gt;
&amp;gt;The string &amp;ldquo;PAYPALISHIRING&amp;rdquo; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)
P   A   H   N
A P L S I I G
Y   I   R
And then read line by line: &amp;ldquo;PAHNAPLSIIGYIR&amp;rdquo;
Write the code that will take a string and make this conversion given a number of rows:
string convert(string text, int nRows);
convert(&amp;ldquo;PAYPALISHIRING&amp;rdquo;, 3) should return &amp;ldquo;PAHNAPLSIIGYIR&amp;rdquo;&lt;/p&gt;

&lt;h3 id=&#34;题意&#34;&gt;题意&lt;/h3&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
   public String convert(String s, int numRows) {
        StringBuilder[] sbs=new StringBuilder[numRows];
        for(int i=0;i&amp;lt;sbs.length;i++){
            sbs[i]=new StringBuilder();
        }
        int index=0;
        for(int i=0;i&amp;lt;s.length();i++){
            sbs[Math.abs(index)].append(s.charAt(i));
            if(index==numRows-1){
                if(index!=0){
                    index=-(numRows-2);
                }
            }else {
                index++;
            }
        }
        StringBuilder result=new StringBuilder();
        for(int i=0;i&amp;lt;sbs.length;i++){
            result.append(sbs[i]);
        }
        return result.toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 7 Reverse Integer</title>
      <link>/post/leetcode-7-reverse-integer/</link>
      <pubDate>Sat, 17 Sep 2016 20:52:05 +0800</pubDate>
      
      <guid>/post/leetcode-7-reverse-integer/</guid>
      <description>

&lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/reverse-integer/&#34;&gt;https://leetcode.com/problems/reverse-integer/&lt;/a&gt;
&amp;gt;Reverse digits of an integer.
Example1: x = 123, return 321
Example2: x = -123, return -321&lt;/p&gt;

&lt;h3 id=&#34;题意&#34;&gt;题意&lt;/h3&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
   public int reverse(int x) {
        boolean negetive=x&amp;lt;0;
        if(negetive)
            x=-x;
        char[] s=(x+&amp;quot;&amp;quot;).toCharArray();
        for(int i=0;i&amp;lt;s.length/2;i++){
            char t=s[i];
            s[i]=s[s.length-1-i];
            s[s.length-1-i]=t;
        }
        int result=0;
        try{
            result=(int) (negetive?-Long.valueOf(new String(s))
                    :Integer.valueOf(new String(s)));
        }catch (Exception e) {
            result=0;
        }
        if(negetive){
            if(result&amp;gt;0)
                result=0;
        }
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 8 String to Integer (atoi)</title>
      <link>/post/leetcode-8-string-to-integer-%28atoi%29/</link>
      <pubDate>Sat, 17 Sep 2016 20:52:05 +0800</pubDate>
      
      <guid>/post/leetcode-8-string-to-integer-%28atoi%29/</guid>
      <description>

&lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/string-to-integer-atoi/&#34;&gt;https://leetcode.com/problems/string-to-integer-atoi/&lt;/a&gt;
&amp;gt;Implement atoi to convert a string to an integer.
Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.
Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.&lt;/p&gt;

&lt;h3 id=&#34;题意&#34;&gt;题意&lt;/h3&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * 字符转数字
     * @param str
     * @return
     */
    public int myAtoi(String str) {
        str=str.trim();
        int max=2147483647;
        int min=-2147483648;
        //如果是空字符串
        if(str==null||str.equals(&amp;quot;&amp;quot;)) return 0;
        //如果第一个非空白字符不是有效字符
        if(!isDigit(str.charAt(0))) return 0;
        StringBuilder sb=new StringBuilder();
        sb.append(str.charAt(0));
        for(int i=1;i&amp;lt;str.length();i++){
            if(isPureDigit(str.charAt(i))){
                sb.append(str.charAt(i));
            }else {
                break;
            }
        }
        //如果长度大于18,早就超过了int的最大范围
        if(sb.length()&amp;gt;=19){
            if(sb.charAt(0)!=&#39;-&#39;)return max;
            else return min;
        }
        if(sb.length()==0){
            return 0;
        }
        //尝试转换
        long result=0;
        try{
            result=Long.valueOf(sb.toString());
        }catch (Exception e) {
            result=0;
        }
        if(result&amp;gt;max)return max;
        if(result&amp;lt;min)return min;
        return (int)result;
    }
    public boolean isDigit(char ch){
        if(ch==&#39;-&#39;||ch==&#39;+&#39;||isPureDigit(ch)){
            return true;
        }
        return false;
    }
    public boolean isPureDigit(char ch){
        if(ch==&#39;0&#39;||ch==&#39;1&#39;||ch==&#39;2&#39;||ch==&#39;3&#39;||ch==&#39;4&#39;||
                ch==&#39;5&#39;||ch==&#39;6&#39;||ch==&#39;7&#39;||ch==&#39;8&#39;||ch==&#39;9&#39;){
            return true;
        }
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 9 Palindrome Number</title>
      <link>/post/leetcode-9-palindrome-number/</link>
      <pubDate>Sat, 17 Sep 2016 20:52:05 +0800</pubDate>
      
      <guid>/post/leetcode-9-palindrome-number/</guid>
      <description>

&lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/palindrome-number/&#34;&gt;https://leetcode.com/problems/palindrome-number/&lt;/a&gt;
&amp;gt;Determine whether an integer is a palindrome. Do this without extra space.
click to show spoilers.
Some hints:
Could negative integers be palindromes? (ie, -1)
If you are thinking of converting the integer to string, note the restriction of using extra space.
You could also try reversing an integer. However, if you have solved the problem &amp;ldquo;Reverse Integer&amp;rdquo;, you know that the reversed integer might overflow. How would you handle such case?
There is a more generic way of solving this problem.
Subscribe to see which companies asked this question&lt;/p&gt;

&lt;h3 id=&#34;题意&#34;&gt;题意&lt;/h3&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    /**
     * 判断回文数字
     * @param x
     * @return
     */
    public boolean isPalindrome(int x) {
        if(x&amp;lt;0)return false;
        if(x==0)return true;
        String s=x+&amp;quot;&amp;quot;;
        for(int i=0;i&amp;lt;s.length()/2;i++){
            if(!(s.charAt(i)==s.charAt(s.length()-1-i))){
                return false;
            }
        }
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 14 Longest Common Prefix</title>
      <link>/post/leetcode-14-longest-common-prefix/</link>
      <pubDate>Sat, 17 Sep 2016 10:41:02 +0800</pubDate>
      
      <guid>/post/leetcode-14-longest-common-prefix/</guid>
      <description>

&lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/longest-common-prefix/&#34;&gt;https://leetcode.com/problems/longest-common-prefix/&lt;/a&gt;
&amp;gt;Write a function to find the longest common prefix string amongst an array of strings.&lt;/p&gt;

&lt;h3 id=&#34;题意&#34;&gt;题意&lt;/h3&gt;

&lt;p&gt;给出一个字符串数组，求最长共同前缀。&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;直接遍历。先遍历每个字符串的第0个字符，看是否相同，然后第1个，类推下去，相同就记录下来，不相同则表示循环要结束了，最长前缀只有这么长。&lt;/p&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public class Solution {
    public String longestCommonPrefix(String[] strs) {
        if(strs==null||strs.length==0)return &amp;quot;&amp;quot;;
        int minLength=Integer.MAX_VALUE;
        for(int i=0;i&amp;lt;strs.length;i++){
            if(strs[i].length()&amp;lt;minLength){
                minLength=strs[i].length();
            }
        }
        StringBuilder sb=new StringBuilder();
        boolean finished=false;
        for(int i=0;i&amp;lt;minLength;i++){
            for(int j=0;j&amp;lt;strs.length-1;j++){
                if(strs[j].charAt(i)!=strs[j+1].charAt(i)){
                    finished=true;
                    break;
                }
            }
            if(!finished){
                sb.append(strs[0].charAt(i));
            }else{
                break;
            }
        }
        return sb.toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>LeetCode 11 Container With Most Water</title>
      <link>/post/leetcode-11-container-with-most-water/</link>
      <pubDate>Sat, 17 Sep 2016 09:48:29 +0800</pubDate>
      
      <guid>/post/leetcode-11-container-with-most-water/</guid>
      <description>

&lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;

&lt;p&gt;Given n non-negative integers a1, a2, &amp;hellip;, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
Note: You may not slant the container.
Subscribe to see which companies asked this question
&lt;a href=&#34;https://leetcode.com/problems/container-with-most-water/&#34;&gt;https://leetcode.com/problems/container-with-most-water/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;题意&#34;&gt;题意&lt;/h3&gt;

&lt;p&gt;给出一个非负的数组a1,a2&amp;hellip;an,这些数可以在坐标系确定若干条垂直于x轴的直线{(1,0)(1,a1)}&amp;hellip;{(n,0)(n,an)}。每两条垂直的直线可以组成一个容器，问在这些组合中，能装水的最大容积&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;定义两个下标：left和right,分别从数组的左边和右边开始往中间靠拢，依次算出面积，如果超过最大值，则更新最大值。&lt;/p&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package xyz.xdzhcs;

public class LeetCode11 {
    public int maxArea(int[] height) {
        int left=0;
        int right=height.length-1;
        int max=-1;
        for(;left&amp;lt;right;){
            if(height[left]&amp;lt;height[right]){
                int area=(right-left)*height[left];
                if(area&amp;gt;max){
                    max=area;
                }
                left++;
            }else {
                int area=(right-left)*height[right];
                if(area&amp;gt;max){
                    max=area;
                }
                right--;
            }
        }
        return max;
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>你好,hugo</title>
      <link>/post/first/</link>
      <pubDate>Wed, 24 Aug 2016 21:13:10 +0800</pubDate>
      
      <guid>/post/first/</guid>
      <description>

&lt;h3 id=&#34;你好-hugo&#34;&gt;你好,hugo&lt;/h3&gt;

&lt;p&gt;这是我的第一篇文章，好吧，测试文章。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>